//#include "Header.h"
//// 함수 복습
//// 함수의 기본 형태
//
//// 반환타입 함수명()
//// {
////		함수 호출 실행할 명령문
//// }
//
//// 1. return 값이 존재하는 함수
//// 반환타입 변수명()
//// {
////	return 반환타입에 맞는 값;
//// }
//// ex) 반환 타입이 int라면 return 값도 int 형태의 값
//
//// 2. return 값이 존재하지 않는 함수(void)
//// void 함수명()
//// {
////		함수 호출 시 실행할 명령문
//// }
//
//// 함수 호출 방법
//// 함수명();
//
//// return의 기능
//// 1. 함수를 종료하고, 함수를 호출한 위치로 이동시킵니다.(return이 없는 경우라면 함수의 명령이 끝나면 자동으로 종료)
//// 2. return 다음에 값이 작성된다면, 함수를 호출한 위치에 해당 값을 전달합니다.
//// 3. c/c++의 return 값은 1개만 전달이 가능합니다.
//
//// 함수의 인수, 매개변수
//// 1. 인수, 인자 값(Argument) : 함수 호출 시 넣어줄 값
//
//// 2. 매개변수(Parameter) : 함수의 도입부 () 부분에 작성될 함수 호출 시 전닯받을 데이터에 대한 표현
//// 사용 예시
//// int sum(int a, int b); <- 정수형 데이터 2개를 요구하는 함수 sum
//// int func(void); <- 매개변수에 void가 적혀있다면, 매개변수가 필요 없음을 명시합니다.
//
//// 변수의 범위(scope)
//// 1. 전역 변수(Globla) : 함수 외부에서 선언된 변수
////						 1. 프로그램 내에 어떤 함수에서도 사용이 가능합니다.
////						 2. 프로그램 실행 중에 메모리 상에 계속 존재합니다.
////						 3. 특정 함수가 전역 변수의 값을 수정할 경우, 다른 함수에서 출력할 때 수정된 값이 나오게 됩니다.
////						 4. 별도로 초기화를 안할 경우 데이터를 초기 값으로 자동 설정됩니다.(정수형 데이터의 0)
//// 2. 지역 변수(Local) : 함수 내부에서 선언된 변수
////						 1. 변수가 선언된 함수 내에서만 사용이 가능합니다.
////						 2. 지역 변수는 함수의 호출 시 생성되며 종료시 삭제됩니다.
////						 3. 함수의 매개변수 또한, 일종의 지역 변수입니다.(함수 호출 시 값을 받고, 변수로 상용되며 종료 시 삭제되기 때문)
//// 3. 정적변수(Static) : 프로그램이 종료되기 전까지 소멸하지 않는 변수
////						 1. static 키워드가 붙은 변수를 의미합니다. ex) static int count;
////						 2. 정적 변수의 초기화는 1번만 진행합니다.
////						 3. 초기화하는 값은 반드시 상수여야 합니다. ex) count = 1;(o), count = a;(x)
////						 4. 함수 내에서 만들어도, 해당 변수는 사라지지 않고 유지됩니다.(정적 지역 변수 : static local)
////						 5. 함수의 매개변수로 사용할 수 없습니다.
////						 6. 변수의 범위가 파일 범위로 제한됩니다.(외부의 코드로 활용이 불가능 : 정적 전역 변수 : statci global)
//
//// 메모리 영역
//// 프로그램에서는 변수, 함수 등을 저장하는 메모리 영역이 존재합니다.
//// 영역 별로 저장되는 데이터들은 다음과 같습니다.
//
//// == COMPILE == 
//
//// 1. Code 영역
//// --> 실행할 프로그램의 코드가 저장되는 영역, 텍스트 영역이라고도 부릅니다.
////		CPU는 코드 영역에 저장되어있는 명령 하나하나를 가져와서 처리합니다.
////		프로그램이 시작하고 종료	하는 순간까지 메모리에 남아있게 됩니다.
//
//// 2. Data 영역
//// --> 프로그램의 전역 변수와 정적 변수가 저장되는 영역입니다.
////		프로그램 시작 시에 할당되면서, 프로그램 종료되면 소멸합니다.
//
//// 3. BSS 영역
//// --> Data 영역에 있는 변수 중에서 초기 값이 없는 전역 변수나 배열, 정적 변수가 저장되는 영역
//
//// === RUNTIME ===
//
//// 4. Heap 영역
//// --> 프로그래머가 직접 메모리를 할당하고 해제하는 영역(동적 할당)
////		c언어에서는 malloc()을 통해 할당을 작업하며, c++에서는 new를 통해 할당을 작업합니다.
////		c언어에서는 free()를 통해 할당을 해제하며, c++에서는 delete를 통해 할당을 해제합니다.
////		선입선출(First-In, First Out : FIFO)로 먼저 들어온 데이터가 먼저 빠져나가게 되는 방식
////		--> 낮은 주소(위)로부터 높은 주소(아래) 방향으로 데이터가 쌓이는 형태
//
//// 5. Stack 영역
//// --> 프로그램이 자동으로 사용하는 임시 메모리 영역
////		함수 호출 시 생성되는 지역 변수나 매개 변수가 저장되는 영역으로, 함수의 호출이 완료되면 해당 데이터는 사라집니다.
////		스택 영역에 저장되는 함수의 호출 정보를 스택 프레임(stack frame)이라고 부릅니다.
////		Stack의 호출에는 리미트가 걸려있고, 일반적인 프로그램은 특정 횟수를 넘을 경우 더이상 호출되지 않도록 막습니다.(Stack Overflow 현상 방지)
////		후입선출(Last-In, First Out : LIFO)로 나중에 들어온 데이터가 먼저 빠져나가게 되는 방식
////		--> 높은 주소(아래)로부터 낮은 주소(위)로 데이터가 쌓이는 형태
//
//// 오버플로(Overflow) : 한정되어있는 메모리 공간이 부족해 메모리 안에 있는 데이터가 넘쳐 흐르는 현상
//// 문제되는 이유 : 데이터가 넘치면 상대 공악을 침범하는 일이 발생할 수 있고 ,이는 데이터를 제대로 불러올 수 없는 상황까지 이어집니다.
//
//int a = 5;
//
//void GlobalF()
//{
//	a++;
//	cout << "(Glabal)" << a << endl;
//}
//
//void localF()
//{
//	int a = 10;
//	a++;
//	cout << "(local)" << a << endl;
//}
//void ParmeterF(int a)
//{
//	a = 20;
//	a++;
//	cout << "(Parameter)" << a << endl;
//}
//void staticF()
//{
//	static int a = 1;
//	a++;
//	cout << "(static)" << a << endl;
//}
//
//int main()
//{
//	cout << "(main/glabal)" << a << endl;
//	GlobalF();
//	cout << "(main/glabal)" << a << endl;
//	int a = 10; // 전역변수 a가 있는 상태에서 지역변수 a가 새로 만들어진다면, 함수 내에서는 지역변수를 우선 처리합니다.
//	GlobalF();
//	cout << "(main/local)" << a << endl; // 현 시점에서 main의 a는 지역변수이기 때문에 GlobalF에 의해 전역변수 a의 값이 올라도, main의 a랑은 전혀 상관 없는 값이 됩니다.
//	ParmeterF(a);
//	cout << "(main/local)" << a << endl; // 매개변수로 a의 "값"을 전달합니다. 그리고 ParameterF에서 그 값을 기반으로 매개변수 a를 할당합니다.
//										 // 그 매개변수 a와 main의 지역변수 a는 서로 다른 데이터입니다.
//										 // call by value(값에 의한 호출) 이라고 부르며, 함수가 종료되도 변경된 내용이 적용되지 않습니다.
//										 // 해결 방안 : call by reference(참조에 의한 전달) : 매개변수를 포이터로 받거나, 참조자로 받으면 전달 가능
//	staticF();
//	cout << "(main/local)" << a << endl; 
//
//	// 5번 연속 출력으로 확인해보는 각 함수의 특징
//	for(int i = 0; i < 5; i++)
//	{
//		GlobalF();
//		localF();
//		ParmeterF(a);
//		staticF();
//		cout << "========================" << endl;
//	}
//	cout << "작업종료" << endl;
//
//	return 0;
//}
