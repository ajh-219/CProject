#include "Header.h"
#include <vector>

// 템플링 코딩(Template Coding)
// >> C++에서는 STL이라는 표준 템플릿을 제공해줍니다.
//	  특정 자료구조에 대한 것들을 제공해줌으로써
//	  편하게 데이터를 사용할 수 있습니다.

// 장점 : 1. 직접 구현하기 번거로울 수 있는 특정 데이터를 구현하지 않고
//			 제공받아 쓰기 때문에 개발 시간이 단축됩니다.
//		  2. 코드의 통일성이 보장되서, 정형화된 개발이 가능합니다.
//		  3. 런타임 속도가 빠른 편입니다.

// 단점 : 1. 컴파일이 느립니다.
//		  2. 파일 규모가 크게 구현됨.

// 벡터(Vector)
// 배열처럼 연속된 메모리 영역을 사용합니다.

// 차이점 
// 배열은 한번 만들면 데이터 추가가 안되지만
// 벡터는 데이터의 추가와 삭제가 가능합니다.

// 벡터의 특징 또는 벡터를 쓰기 적합한 상황
// 1. 저장하고자하는 데이터의 갯수가 가변적일 경우
// 2. 중간에 위치한 데이터를 삭제하거나 삽입하지 않는 상황
//  --> 불가능한건 아니나 비효율이기에 이런 상황이면 피한다.(속도 오래 걸림)
// 3. 검색 기능이 많이 필요하지 않은 경우
//  --> 효율 문제
// 4. 특정 위치에 있는 데이터를 빠르게 접근하는 경우
//  --> 배열처럼 인덱스 개념으로 접근하기 때문에 좋음.



int main()
{
	// 1. 벡터 생성
	// vevtor<자료형> 벡터명;
	vector<int> v; // int 형태의 데이터를 저장할 수 있는 vector
	vector<string> v2; // string 형태의 데이터를 저장할 수 있는 vector

	// 2. 벡터 생성 + 크기 설정
	// vector<자료형> 벡터명(크기);
	vector<int> v3(5); // int형 벡터, 저장 크기 = 5개, 기본 값 0

	// 3. 벡터 생성과 값 초기화
	// vector<자료형> 벡터명 = {값1, 값2, 값3, ...};
	vector<string> v4 = { "A1", "A2", "A3" };
	// string형 벡터, 저장 크기 = 3개, 값 : [A1, A2, A3]
	
	// 4. 벡터 배열
	// vector<자료형> 벡터명 ={{값1, 값2}, {값1, 값2}}
	vector<int> v5[] = {{1,2}, {3,4}};
	vector<vector<int>> v6;
	// vector<int> 형 벡터

	// 벡터 사용해보기
	vector<string> menu;

	// 벡터에 데이터 추가
	menu.push_back("기본김밥");
	// menu.push_back(1); vector가 string으로 지정되어 있기 때문에
	// string 이외의 데이터는 들어갈 수 없습니다.
	// 이런 부분이 STL을 사용하는 이유 중 하나입니다.(타입 안전성)
	menu.push_back("소고기 김밥");
	menu.push_back("참치김밥");

	// 값 접근
	cout << menu[0] << endl; // 배열과 동일

	// 전체 출력
	// 벡터명.size()는 현재 벡터의 크기(데이터 개수)를 return 합니다.
	for (int i = 0; i < menu.size(); i++)
	{
		cout << menu[i] << endl;
	}

	// 값 제거
	menu.pop_back(); // 맨 마지막 데이터가 삭제됩니다.

	// 전체 출력(iterator)
	// iterator는 STL 자료구조의 데이터를 순차적으로 접근할 수 있는 데이터입니다.
	// 해당 문법을 활용할 경우, STL에서는 동일 한 문법으로 데이터를 뽑을 수 있어 사용됩니다.

	// 배열 for문(묶음 형태일 때만 사용 가능)
	// for(자료형 변수명 : 묶음형 데이터)
	//{
	//	여기서 변수명은 해당 데이터의 각각의 값을 의미합니다.
	//	반복할 때마다 자동으로 다음 값으로 넘어갑니다.
	//}
	for (auto iter : menu)
	{
		cout << iter << endl;
	}

	// 일반적인 for문으로 iterator 쓰기
	// 벡터.begin() : 벡터의 시작 값(iterator 기준)
	// 벡터.end() : 벡터의 마지막 값(iterator 기준)
	for (auto iter = menu.begin(); iter < menu.end(); iter++)
	{
		cout << *iter << endl;
		// 위치 기반으로 찾기 때문에 가리키는 문법인 포인터(*)를 활용
	}


	return 0;
}